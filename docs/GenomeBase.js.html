<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>GenomeBase.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Epigenome.html">Epigenome</a><ul class='methods'><li data-type='method'><a href="Epigenome.html#compile">compile</a></li><li data-type='method'><a href="Epigenome.html#copy">copy</a></li><li data-type='method'><a href="Epigenome.html#crossover">crossover</a></li><li data-type='method'><a href="Epigenome.html#fillRandom">fillRandom</a></li><li data-type='method'><a href="Epigenome.html#getRandomGeneValue">getRandomGeneValue</a></li><li data-type='method'><a href="Epigenome.html#howSimilar">howSimilar</a></li><li data-type='method'><a href="Epigenome.html#isEqual">isEqual</a></li><li data-type='method'><a href="Epigenome.html#mutate">mutate</a></li><li data-type='method'><a href="Epigenome.html#selection">selection</a></li><li data-type='method'><a href="Epigenome.html#toRandom">toRandom</a></li></ul></li><li><a href="Generation.html">Generation</a><ul class='methods'><li data-type='method'><a href="Generation.html#next">next</a></li></ul></li><li><a href="Genome.html">Genome</a><ul class='methods'><li data-type='method'><a href="Genome.html#copy">copy</a></li><li data-type='method'><a href="Genome.html#crossover">crossover</a></li><li data-type='method'><a href="Genome.html#fillRandom">fillRandom</a></li><li data-type='method'><a href="Genome.html#getRandomGeneValue">getRandomGeneValue</a></li><li data-type='method'><a href="Genome.html#howSimilar">howSimilar</a></li><li data-type='method'><a href="Genome.html#isEqual">isEqual</a></li><li data-type='method'><a href="Genome.html#mutate">mutate</a></li><li data-type='method'><a href="Genome.html#selection">selection</a></li><li data-type='method'><a href="Genome.html#toRandom">toRandom</a></li></ul></li><li><a href="Individual.html">Individual</a><ul class='methods'><li data-type='method'><a href="Individual.html#crossover">crossover</a></li><li data-type='method'><a href="Individual.html#evaluate">evaluate</a></li><li data-type='method'><a href="Individual.html#mutate">mutate</a></li></ul></li><li><a href="Phenotype.html">Phenotype</a><ul class='methods'><li data-type='method'><a href="Phenotype.html#apply">apply</a></li></ul></li><li><a href="Population.html">Population</a><ul class='methods'><li data-type='method'><a href="Population.html#evolve">evolve</a></li><li data-type='method'><a href="Population.html#fossilize">fossilize</a></li><li data-type='method'><a href="Population.html#stats">stats</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#MutationMethod">MutationMethod</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">GenomeBase.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Creates a new Genome.
 *
 * @exports GenomeBase
 * @private
 * @class GenomeBase
 * @param {Genome|Array|Number|undefined} genome - An array of genes or a number indicating the length of the genome.
 * @extends {Array}
 */
export class GenomeBase extends Array {

  constructor(genes) {
    if (Number.isSafeInteger(genes) &amp;&amp; genes >= 0) {
      super();
      this.size = genes;
    } else if (Array.isArray(genes)) {
      super(...genes);
    } else {
      super();
    }
  }

  /**
   * Override this to create a gene type.
   *
   * @abstract
   * @returns any
   * @memberof GenomeBase
   */
  getRandomGeneValue() {
    console.error("Not implemented.");
    return undefined;
  }

  /**
   * Size is the same as length.
   *
   * @memberof GenomeBase
   */
  get size() {
    return this.length;
  }

  /**
   * Setting size equivalent to setting length, but new positions are automatically populated with gene values.
   *
   * @memberof GenomeBase
   */
  set size(length) {
    let start = this.length;
    this.length = length;
    if (start &lt; length) {
      this.fillRandom(start, length - 1);
    }
  }

  /**
   * Sets a gene position to a random value.
   *
   * @param {integer} index
   * @returns Genome - Genome with position filled by a random gene value.
   * @memberof GenomeBase
   */
  toRandom(index) {
    this[index] = this.getRandomGeneValue();
    return this;
  }

  /**
   * Set gene values form start to stop to random values.
   *
   * @param {integer} [start=0]
   * @param {integer} [stop=this.length - 1]
   * @returns Genome - Genome with positions filled by random gene values.
   * @memberof GenomeBase
   */
  fillRandom(start = 0, stop = this.length - 1) {
    for (let i = start; i &lt; stop + 1; i++) {
      this.toRandom(i);
    }
    return this;
  }

  /**
   *  Select genes at a certain rate.
   *
   * @param {number} rate
   * @returns integer[] - An array of selected gene positions.
   * @memberof GenomeBase
   */
  selection(rate) {
    return this.reduce((selection, gene, i) => {
      if (Math.random() &lt;= rate) {
        selection.push(i);
      }
      return selection;
    }, []);
  }

  /**
   * Returns Genome.Mutations.
   *
   * @readonly
   * @memberof Genome
   */
  get mutations() {
    return this.constructor.Mutations;
  }

  /**
   * Apply mutations to genome.
   *
   * @param {Object|Array} options - Options specifying a single mutation or an array of options as a pipeline of mutations.
   * @param {String|Function} options.mutation - Mutation name or function.
   * @param {String|Function} options.params - .Values for the mutation.
   * @param {GenomeBase~requestMutationDetails} callback - Callback passed the mutation outcomes.
   * @returns Genome - Returns the same genome, with mutation or mutation pipeline applied, unless specified.
   * @memberof GenomeBase
   */
  mutate(options, callback) {
    let {
      deletion = 0,
      duplication = 0,
      inversion = 0,
      incrementation = 0,
      increment = 0,
      substitution = 0.0,
      modify = true,
      upper = Infinity,
      lower = 1
    } = options || {};
    let genome = modify ? this : this.copy();
    // Chance to duplicate something.
    // Duplication limitations.
    genome._duplication(duplication);
    // Chance to inverse a section.
    // Inverse limitations.
    genome._inversion(inversion);
    // Chance for substitution.
    // Substitution limitations.
    genome._substitution(substitution);
    // Chance for deletion.
    // Deletion limitations.
    genome._deletion(deletion);
    // Chance for incrementation.
    // Amount to increment.
    genome._incrementation(incrementation, increment);
    // Truncate the genome to the max size.
    if (Number.isFinite(upper) &amp;&amp; genome.size > upper) {
      genome.size = upper;
    }
    // Increase the genome to the minimum size.
    if (Number.isFinite(lower) &amp;&amp; genome.size &lt; lower) {
      genome.size = lower;
    }
    return genome;
  }

  /**
   * @callback GenomeBase~requestMutationDetails
   * @param {Array} mutations - Captured mutations from mutation pipeline.
   * @param {Array} mutations[].mutation - Mutation applied.
   * @param {Array} mutations[].selection - Positions mutation options were applied to.
   * @param {Array} mutations[].params - Mutation options applied.
   * @param {Genome} genome - Pre-mutation Genome shallow copy.
   * @param {Genome} mutated - Mutated Genome shallow copy.
   */

  /**
   * Create a new Genome by selecting genes from multiple parents.
   *
   * @param {Object|Array} options - Options specifying a single crossover mechanism or an array of options as a pipeline of crossover mechanisms.
   * @param {Genome|Array|Genome[]|Array[]} mates - Genomes used in crossover.
   * @param {GenomeBase~requestCrossoverDetails} callback - Callback passed the mutation outcomes.
   * @returns Genome - Genome created using the genes of this Genome and mates.
   * @memberof GenomeBase
   */
  crossover(options, mates, callback) {
    // Random chance any particular gene is from either parent.
    // Splice, Pivot Splice
    // Genes retain position or not.
    // Splice or average splice.
    // Crossover is sectional or uniform.
    let {
      crossover = 1 - 1 / mates.length,
      modify = false,
      average = false
    } = options;
    let child = modify ? this : this.slice();
    // Retrieve a selection of gene indexes that will be changed.
    let selection = child.selection(crossover);
    // Set that gene equally from all parents.
    selection.forEach(selected => {
      let geneMate = mates[Math.floor(Math.random() * mates.length)];
      // If mate doesn't contain gene length, abort.
      let cross = geneMate.length > selected
        ? geneMate[selected]
        : child[selected];
      child.splice(selected, 1, cross);
    });
    return child;
  }
  /**
   * @callback GenomeBase~requestCrossoverDetails
   * @param {Array} crossovers - Captured mutations from mutation pipeline.
   * @param {Array} crossovers[].crossover - Crossover options applied.
   * @param {Array} crossovers[].selection - Positions crossover options were applied to.
   * @param {Array} crossovers[].parent_selection - Parents chosen for each crossover position.
   * @param {Genome[]} parents - Array of parent genomes.
   * @param {Genome} child - Child Genome.
   */

  /* Helper Methods */
  /**
   * Creates a shallow copy of this genome.
   *
   * @returns Genome - A shallow copy of this genome.
   * @memberof GenomeBase
   */
  copy() {
    return this.slice();
  }

  /**
   * Determine if this genome is equal to another.
   *
   * @param {Genome|Array} genome - Genome for comparison.
   * @returns boolean - The genomes have the same values at the same positions and are of the same length.
   * @memberof GenomeBase
   */
  isEqual(genome) {
    if (this.length !== genome.length) {
      return false;
    }
    return this.every((value, index) => genome[index] === value);
  }

  /**
   * Find the percentage of shared genes.
   *
   * @param {Genome|Array} genome - Genome for comparison.
   * @returns Number - The percentage of same genes at same gene positions compared to the longest of the two genomes.
   * @memberof GenomeBase
   */
  howSimilar(genome) {
    return (
      this.reduce((n, v, i) => (this[i] === genome[i] ? n + 1 : n), 0) /
      (this.length > genome.length ? this.length : genome.length)
    );
  }
}

/* Genetic mutation operators. */
/**
 * Extend available mutation methods.
 * @function MutationMethod
 * @param {Genome|Array} genome - Genome to mutate.
 * @param {integer[]} selection - Genome positions to apply mutation to.
 * @param {Object} params - Mutation parameters.
 */
GenomeBase.Mutations =  {
  deletion(genome, selection, rate) {
    let selection = this.selection(rate);
    // Group consecutive selections.
    selection.reverse().forEach(selected => {
      this.splice(selected, 1);
    });
  },
  // Repeat, in place, contiguously selected.
  duplication(rate) {
    let selection = this.selection(rate),
      groupedSelection = selection.reduce(
        (groups, selected) => {
          let currentGroup = groups[groups.length - 1];
          if (currentGroup[currentGroup.length - 1] === selected - 1) {
            currentGroup.push(selected);
          } else {
            groups.push([selected]);
          }
          return groups;
        },
        [[]]
      );
    groupedSelection.reverse().forEach(group => {
      this.splice(group[0], 0, ...group.map(i => this[i]));
    });
  },
  // Invert, in place, contiguously selected.
  inversion(rate) {
    let selection = this.selection(rate),
      groupedSelection = selection.reduce(
        (groups, selected) => {
          let currentGroup = groups[groups.length - 1];
          if (currentGroup[currentGroup.length - 1] === selected - 1) {
            currentGroup.push(selected);
          } else {
            if (currentGroup.length === 1) {
              currentGroup[0] = selected;
            } else {
              groups.push([selected]);
            }
          }
          return groups;
        },
        [[]]
      );
    groupedSelection.forEach(group => {
      this.splice(group[0], group.length, ...group.reverse().map(i => this[i]));
    });
  },
  // Set selected to a random value.
  substitution(rate) {
    let selection = this.selection(rate);
    selection.forEach(selected => {
      this.toRandom(selected);
    });
  }
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sat Jul 01 2017 14:56:30 GMT-0400 (EDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
